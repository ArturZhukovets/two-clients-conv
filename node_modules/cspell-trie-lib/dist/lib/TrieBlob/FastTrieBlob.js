import { findNode } from '../ITrieNode/trie-util.js';
import { mergeOptionalWithDefaults } from '../utils/mergeOptionalWithDefaults.js';
import { extractInfo } from './FastTrieBlobBitMaskInfo.js';
import { assertSorted, FastTrieBlobInternals, sortNodes } from './FastTrieBlobInternals.js';
import { FastTrieBlobIRoot } from './FastTrieBlobIRoot.js';
import { TrieBlob } from './TrieBlob.js';
import { Utf8Accumulator } from './Utf8.js';
const useSorted = true;
const checkSorted = false;
export class FastTrieBlob {
    nodes;
    _charIndex;
    bitMasksInfo;
    sorted;
    _readonly = false;
    _forbidIdx;
    _iTrieRoot;
    wordToCharacters;
    info;
    constructor(nodes, _charIndex, bitMasksInfo, sorted, options) {
        this.nodes = nodes;
        this._charIndex = _charIndex;
        this.bitMasksInfo = bitMasksInfo;
        this.sorted = sorted;
        this.info = mergeOptionalWithDefaults(options);
        this.wordToCharacters = (word) => [...word];
        this._forbidIdx = this._searchNodeForChar(0, this.info.forbiddenWordPrefix);
        if (sorted && checkSorted) {
            assertSorted(nodes, bitMasksInfo.NodeMaskChildCharIndex);
        }
    }
    wordToNodeCharIndexSequence(word) {
        return this._charIndex.wordToUtf8Seq(word);
    }
    letterToNodeCharIndexSequence(letter) {
        return this._charIndex.getCharUtf8Seq(letter);
    }
    has(word) {
        return this._has(0, word);
    }
    _has(nodeIdx, word) {
        return this.sorted && useSorted ? this.#hasSorted(nodeIdx, word) : this.#has(nodeIdx, word);
    }
    #has(nodeIdx, word) {
        const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
        const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
        const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
        const nodes = this.nodes;
        const charIndexes = this.wordToNodeCharIndexSequence(word);
        const len = charIndexes.length;
        let node = nodes[nodeIdx];
        for (let p = 0; p < len; ++p, node = nodes[nodeIdx]) {
            const letterIdx = charIndexes[p];
            const count = node.length;
            let i = count - 1;
            for (; i > 0; --i) {
                if ((node[i] & NodeMaskChildCharIndex) === letterIdx) {
                    break;
                }
            }
            if (i < 1)
                return false;
            nodeIdx = node[i] >>> NodeChildRefShift;
            if (!nodeIdx)
                return false;
        }
        return !!(node[0] & NodeMaskEOW);
    }
    #hasSorted(nodeIdx, word) {
        const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
        const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
        const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
        const nodes = this.nodes;
        const charIndexes = this.wordToNodeCharIndexSequence(word);
        const len = charIndexes.length;
        let node = nodes[nodeIdx];
        for (let p = 0; p < len; ++p, node = nodes[nodeIdx]) {
            const letterIdx = charIndexes[p];
            const count = node.length;
            // console.error('%o', { p, letterIdx, ...this.nodeInfo(nodeIdx) });
            if (count < 2)
                return false;
            let i = 1;
            let j = count - 1;
            let c = -1;
            while (i < j) {
                const m = (i + j) >> 1;
                c = node[m] & NodeMaskChildCharIndex;
                if (c < letterIdx) {
                    i = m + 1;
                }
                else {
                    j = m;
                }
            }
            if (i >= count || (node[i] & NodeMaskChildCharIndex) !== letterIdx)
                return false;
            nodeIdx = node[i] >>> NodeChildRefShift;
            if (!nodeIdx)
                return false;
        }
        return !!(node[0] & NodeMaskEOW);
    }
    *words() {
        const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
        const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
        const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
        const nodes = this.nodes;
        const accumulator = Utf8Accumulator.create();
        const stack = [{ nodeIdx: 0, pos: 0, word: '', accumulator }];
        let depth = 0;
        while (depth >= 0) {
            const { nodeIdx, pos, word, accumulator } = stack[depth];
            const node = nodes[nodeIdx];
            if (!pos && node[0] & NodeMaskEOW) {
                yield word;
            }
            if (pos >= node.length - 1) {
                --depth;
                continue;
            }
            const nextPos = ++stack[depth].pos;
            const entry = node[nextPos];
            const charIdx = entry & NodeMaskChildCharIndex;
            const acc = accumulator.clone();
            const codePoint = acc.decode(charIdx);
            const letter = (codePoint && String.fromCodePoint(codePoint)) || '';
            ++depth;
            stack[depth] = {
                nodeIdx: entry >>> NodeChildRefShift,
                pos: 0,
                word: word + letter,
                accumulator: acc,
            };
        }
    }
    toTrieBlob() {
        const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
        const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
        const nodes = this.nodes;
        function calcNodeToIndex(nodes) {
            let offset = 0;
            const idx = Array(nodes.length + 1);
            for (let i = 0; i < nodes.length; ++i) {
                idx[i] = offset;
                offset += nodes[i].length;
            }
            idx[nodes.length] = offset;
            return idx;
        }
        const nodeToIndex = calcNodeToIndex(nodes);
        const nodeElementCount = nodeToIndex[nodeToIndex.length - 1];
        const binNodes = new Uint32Array(nodeElementCount);
        const lenShift = TrieBlob.NodeMaskNumChildrenShift;
        const refShift = TrieBlob.NodeChildRefShift;
        let offset = 0;
        for (let i = 0; i < nodes.length; ++i) {
            const node = nodes[i];
            // assert(offset === nodeToIndex[i]);
            binNodes[offset++] = ((node.length - 1) << lenShift) | node[0];
            for (let j = 1; j < node.length; ++j) {
                const v = node[j];
                const nodeRef = v >>> NodeChildRefShift;
                const charIndex = v & NodeMaskChildCharIndex;
                binNodes[offset++] = (nodeToIndex[nodeRef] << refShift) | charIndex;
            }
        }
        return new TrieBlob(binNodes, this._charIndex, this.info);
    }
    isReadonly() {
        return this._readonly;
    }
    freeze() {
        this._readonly = true;
        return this;
    }
    toJSON() {
        return {
            info: this.info,
            nodes: nodesToJSON(this.nodes),
            // charIndex: this._charIndex,
        };
    }
    static create(data, options) {
        return new FastTrieBlob(data.nodes, data.charIndex, extractInfo(data), data.sorted, options);
    }
    static toITrieNodeRoot(trie) {
        return new FastTrieBlobIRoot(new FastTrieBlobInternals(trie.nodes, trie._charIndex, trie.bitMasksInfo), 0, trie.info);
    }
    static NodeMaskEOW = TrieBlob.NodeMaskEOW;
    static NodeChildRefShift = TrieBlob.NodeChildRefShift;
    static NodeMaskChildCharIndex = TrieBlob.NodeMaskChildCharIndex;
    static DefaultBitMaskInfo = {
        NodeMaskEOW: FastTrieBlob.NodeMaskEOW,
        NodeMaskChildCharIndex: FastTrieBlob.NodeMaskChildCharIndex,
        NodeChildRefShift: FastTrieBlob.NodeChildRefShift,
    };
    get iTrieRoot() {
        return (this._iTrieRoot ??= FastTrieBlob.toITrieNodeRoot(this));
    }
    getRoot() {
        return this.iTrieRoot;
    }
    getNode(prefix) {
        return findNode(this.getRoot(), prefix);
    }
    isForbiddenWord(word) {
        return !!this._forbidIdx && this._has(this._forbidIdx, word);
    }
    hasForbiddenWords() {
        return !!this._forbidIdx;
    }
    nodeInfo(nodeIndex, accumulator) {
        const acc = accumulator ?? Utf8Accumulator.create();
        const n = this.nodes[nodeIndex];
        const eow = !!(n[0] & this.bitMasksInfo.NodeMaskEOW);
        const children = n.slice(1).map((v) => {
            const cIdx = v & this.bitMasksInfo.NodeMaskChildCharIndex;
            const a = acc.clone();
            const codePoint = a.decode(cIdx);
            const c = codePoint !== undefined ? String.fromCodePoint(codePoint) : 'âˆŽ';
            const i = v >>> this.bitMasksInfo.NodeChildRefShift;
            return { c, i, cIdx };
        });
        return { eow, children };
    }
    /** number of nodes */
    get size() {
        return this.nodes.length;
    }
    _lookupCharIndexNode(nodeIdx, charIndex) {
        const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
        const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
        const nodes = this.nodes;
        const node = nodes[nodeIdx];
        const letterIdx = charIndex;
        const count = node.length;
        let i = count - 1;
        for (; i > 0; --i) {
            if ((node[i] & NodeMaskChildCharIndex) === letterIdx) {
                return node[i] >>> NodeChildRefShift;
            }
        }
        return 0;
    }
    /** Search from nodeIdx for the node index representing the character. */
    _searchNodeForChar(nodeIdx, char) {
        const charIndexes = this.letterToNodeCharIndexSequence(char);
        let idx = nodeIdx;
        for (let i = 0; i < charIndexes.length; ++i) {
            idx = this._lookupCharIndexNode(idx, charIndexes[i]);
            if (!idx)
                return 0;
        }
        return idx;
    }
    get charIndex() {
        return [...this._charIndex.charIndex];
    }
    static fromTrieBlob(trie) {
        const bitMasksInfo = {
            NodeMaskEOW: TrieBlob.NodeMaskEOW,
            NodeMaskChildCharIndex: TrieBlob.NodeMaskChildCharIndex,
            NodeChildRefShift: TrieBlob.NodeChildRefShift,
        };
        const trieNodesBin = TrieBlob.nodesView(trie);
        const nodeOffsets = [];
        for (let offset = 0; offset < trieNodesBin.length; offset += (trieNodesBin[offset] & TrieBlob.NodeMaskNumChildren) + 1) {
            nodeOffsets.push(offset);
        }
        const offsetToNodeIndex = new Map(nodeOffsets.map((offset, i) => [offset, i]));
        const nodes = Array.from({ length: nodeOffsets.length });
        for (let i = 0; i < nodes.length; ++i) {
            const offset = nodeOffsets[i];
            const n = trieNodesBin[offset];
            const eow = n & TrieBlob.NodeMaskEOW;
            const count = n & TrieBlob.NodeMaskNumChildren;
            // Preallocate the array to the correct size.
            const node = Array.from({ length: count + 1 });
            node[0] = eow;
            nodes[i] = node;
            for (let j = 1; j <= count; ++j) {
                const n = trieNodesBin[offset + j];
                const charIndex = n & TrieBlob.NodeMaskChildCharIndex;
                const nodeIndex = n >>> TrieBlob.NodeChildRefShift;
                const idx = offsetToNodeIndex.get(nodeIndex);
                if (idx === undefined) {
                    throw new Error(`Invalid node index ${nodeIndex}`);
                }
                node[j] = (idx << TrieBlob.NodeChildRefShift) | charIndex;
            }
        }
        return new FastTrieBlob(sortNodes(nodes, TrieBlob.NodeMaskChildCharIndex), trie.charIndex, bitMasksInfo, true, trie.info);
    }
    static isFastTrieBlob(obj) {
        return obj instanceof FastTrieBlob;
    }
}
export function nodesToJSON(nodes) {
    const mapNodeToAcc = new Map();
    function mapNode(node, i) {
        if (node.length === 1) {
            return {
                i,
                w: (!!(node[0] & TrieBlob.NodeMaskEOW) && 1) || 0,
            };
        }
        const acc = mapNodeToAcc.get(node) || Utf8Accumulator.create();
        function mapChild(n) {
            const index = n >>> TrieBlob.NodeChildRefShift;
            const seq = n & TrieBlob.NodeMaskChildCharIndex;
            const cAcc = acc.clone();
            const codePoint = cAcc.decode(seq);
            if (codePoint === undefined) {
                mapNodeToAcc.set(nodes[index], cAcc);
            }
            return {
                i: index,
                c: codePoint && String.fromCodePoint(codePoint),
                s: seq.toString(16).padStart(2, '0'),
            };
        }
        return {
            i,
            w: (!!(node[0] & TrieBlob.NodeMaskEOW) && 1) || 0,
            c: node.slice(1).map(mapChild),
        };
    }
    return nodes.map((n, i) => mapNode(n, i));
}
//# sourceMappingURL=FastTrieBlob.js.map